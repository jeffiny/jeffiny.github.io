<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>qlib源码解析-DataLoader</title>
    <link href="/2024/12/07/qlib-1/"/>
    <url>/2024/12/07/qlib-1/</url>
    
    <content type="html"><![CDATA[<p>DataLoader：父类</p><ul><li>这是一个抽象基类,定义了数据加载的基本接口</li><li>核心方法是 <code>load()</code>,用于加载数据并返回 DataFrame 格式</li><li>load 方法支持按时间范围和标的物(instruments)筛选数据</li><li>返回的数据包含特征(feature)和标签(label)两部分,使用多级列索引<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataLoader</span>(abc.ABC):  <br>    <span class="hljs-string">&quot;&quot;&quot;  </span><br><span class="hljs-string">    DataLoader is designed for loading raw data from original data source.    </span><br><span class="hljs-string">    &quot;&quot;&quot;</span>  <br><span class="hljs-meta">    @abc.abstractmethod  </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load</span>(<span class="hljs-params">self, instruments, start_time=<span class="hljs-literal">None</span>, end_time=<span class="hljs-literal">None</span></span>) -&gt; pd.DataFrame:  <br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    parameters:</span><br><span class="hljs-string">instuments:str or dict</span><br><span class="hljs-string">生成于InstrumentProvider：提供标准化的交易品种信息</span><br><span class="hljs-string">start_time:str</span><br><span class="hljs-string">end_time:str</span><br><span class="hljs-string">&quot;&quot;&quot;</span>   <br></code></pre></td></tr></table></figure></li></ul><p>python语法解释：</p><hr><ol><li><code>abc.ABC</code>的含义：</li></ol><ul><li>abc是Python的<code>Abstract Base Classes</code>(抽象基类)模块</li><li>ABC是Abstract Base Class的缩写</li><li>当一个类继承自<code>abc.ABC</code>，就表明这个类是一个抽象类</li><li>抽象类是不能被直接实例化的类，需要被其他类继承并实现其抽象方法</li></ul><ol start="2"><li><code>def load(self, instruments, start_time=None, end_time=None) -&gt; pd.DataFrame:</code>的语法解析：</li></ol><ul><li><code>-&gt;</code> 是Python的类型注解语法，表示函数返回值的类型</li><li><code>-&gt; pd.DataFrame</code> 表示这个函数会返回一个pandas的DataFrame对象</li><li><code>start_time=None, end_time=None</code> 是参数的默认值设置</li><li>完整语法可以理解为：这是一个名为load的方法，接受self, instruments参数，以及可选的start_time和end_time参数，并返回DataFrame类型的数据</li></ul><ol start="3"><li>load函数内没有语句的含义：</li></ol><ul><li>这是因为这是一个抽象方法（被abc.abstractmethod装饰器修饰）</li><li>抽象方法只定义接口，不需要具体实现</li><li>继承这个类的子类必须实现这个方法</li><li>相当于一个”契约”，规定了所有子类必须遵循的接口规范</li></ul><hr><p>StaticDataLoader：继承DataLoader和Serializable</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticDataLoader</span>(DataLoader, Serializable):  <br>    <span class="hljs-string">&quot;&quot;&quot;  </span><br><span class="hljs-string">    DataLoader that supports loading data from file or as provided.    </span><br><span class="hljs-string">    &quot;&quot;&quot;</span>  <br>    include_attr = [<span class="hljs-string">&quot;_config&quot;</span>]  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config: <span class="hljs-type">Union</span>[<span class="hljs-built_in">dict</span>, <span class="hljs-built_in">str</span>, pd.DataFrame], join=<span class="hljs-string">&quot;outer&quot;</span></span>):  <br>        <span class="hljs-string">&quot;&quot;&quot;  </span><br><span class="hljs-string">        Parameters      </span><br><span class="hljs-string">config : dict           </span><br><span class="hljs-string">&#123;fields_group: &lt;path or object&gt;&#125;        </span><br><span class="hljs-string">join : str            </span><br><span class="hljs-string">How to align different dataframes        </span><br><span class="hljs-string">&quot;&quot;&quot;</span>        <br>        <span class="hljs-variable language_">self</span>._config = config  <br>        <span class="hljs-comment"># using &quot;_&quot; to avoid confliction with the method `config` of Serializable  </span><br>        <span class="hljs-variable language_">self</span>.join = join  <br>        <span class="hljs-variable language_">self</span>._data = <span class="hljs-literal">None</span>  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getstate__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">dict</span>:  <br>        <span class="hljs-comment"># avoid pickling `self._data`  </span><br>        <span class="hljs-keyword">return</span> &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.__dict__.items() <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> k.startswith(<span class="hljs-string">&quot;_&quot;</span>)&#125;  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load</span>(<span class="hljs-params">self, instruments=<span class="hljs-literal">None</span>, start_time=<span class="hljs-literal">None</span>, end_time=<span class="hljs-literal">None</span></span>) -&gt; pd.DataFrame:  <br>        <span class="hljs-variable language_">self</span>._maybe_load_raw_data()  <br>  <br>        <span class="hljs-comment"># 1) Filter by instruments  </span><br>        <span class="hljs-keyword">if</span> instruments <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <br>            df = <span class="hljs-variable language_">self</span>._data  <br>        <span class="hljs-keyword">else</span>:  <br>            df = <span class="hljs-variable language_">self</span>._data.loc(axis=<span class="hljs-number">0</span>)[:, instruments]  <br>  <br>        <span class="hljs-comment"># 2) Filter by Datetime  </span><br>        <span class="hljs-keyword">if</span> start_time <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> end_time <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <br>            <span class="hljs-keyword">return</span> df  <span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> avoid copy by loc  </span><br>        <span class="hljs-comment"># pd.Timestamp(None) == NaT, use NaT as index can not fetch correct thing, so do not change None.        </span><br>        start_time = time_to_slc_point(start_time)  <br>        end_time = time_to_slc_point(end_time)  <br>        <span class="hljs-keyword">return</span> df.loc[start_time:end_time]  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_maybe_load_raw_data</span>(<span class="hljs-params">self</span>):  <br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._data <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:  <br>            <span class="hljs-keyword">return</span>  <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(<span class="hljs-variable language_">self</span>._config, <span class="hljs-built_in">dict</span>):  <br>            <span class="hljs-variable language_">self</span>._data = pd.concat(  <br>                &#123;fields_group: load_dataset(path_or_obj) <span class="hljs-keyword">for</span> fields_group, path_or_obj <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>._config.items()&#125;,  <br>                axis=<span class="hljs-number">1</span>,  <br>                join=<span class="hljs-variable language_">self</span>.join,  <br>            )  <br>            <span class="hljs-variable language_">self</span>._data.sort_index(inplace=<span class="hljs-literal">True</span>)  <br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(<span class="hljs-variable language_">self</span>._config, (<span class="hljs-built_in">str</span>, Path)):  <br>            <span class="hljs-keyword">with</span> Path(<span class="hljs-variable language_">self</span>._config).<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:  <br>                <span class="hljs-variable language_">self</span>._data = pickle.load(f)  <br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(<span class="hljs-variable language_">self</span>._config, pd.DataFrame):  <br>            <span class="hljs-variable language_">self</span>._data = <span class="hljs-variable language_">self</span>._config<br></code></pre></td></tr></table></figure><hr><p>继承自 DataLoader,用于从文件或已有数据中加载数据<br><strong>主要属性:</strong></p><ul><li>config: 可以是字典、字符串路径或 DataFrame</li><li>join: 定义如何对齐不同的数据框</li><li>data: 缓存加载的数据<br><strong>核心方法:</strong></li><li>load(): 实现了基类的抽象方法,支持按时间和标的过滤数据</li><li>maybe_load_raw_data(): 负责实际的数据加载逻辑</li><li>支持从字典配置加载多个数据源并合并</li><li>支持从pickle文件加载</li><li>支持直接使用DataFrame数据</li></ul><hr><p>其中用到的两个函数，自定义路径如下：</p><p>load_dataset()的主要目的就是根据不同的文件格式进行读取，并且转换为pandas</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_dataset</span>(<span class="hljs-params">path_or_obj, index_col=[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]</span>):  <br>    <span class="hljs-string">&quot;&quot;&quot;load dataset from multiple file formats&quot;&quot;&quot;</span>  <br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(path_or_obj, pd.DataFrame):  <br>        <span class="hljs-keyword">return</span> path_or_obj  <br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(path_or_obj):  <br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;file <span class="hljs-subst">&#123;path_or_obj&#125;</span> doesn&#x27;t exist&quot;</span>)  <br>    _, extension = os.path.splitext(path_or_obj)  //分离文件名和扩展名<br>    <span class="hljs-keyword">if</span> extension == <span class="hljs-string">&quot;.h5&quot;</span>:  <br>        <span class="hljs-keyword">return</span> pd.read_hdf(path_or_obj)  <br>    <span class="hljs-keyword">elif</span> extension == <span class="hljs-string">&quot;.pkl&quot;</span>:  <br>        <span class="hljs-keyword">return</span> pd.read_pickle(path_or_obj)  <br>    <span class="hljs-keyword">elif</span> extension == <span class="hljs-string">&quot;.csv&quot;</span>:  <br>        <span class="hljs-keyword">return</span> pd.read_csv(path_or_obj, parse_dates=<span class="hljs-literal">True</span>, index_col=index_col)  <br>    <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;unsupported file type `<span class="hljs-subst">&#123;extension&#125;</span>`&quot;</span>)<br></code></pre></td></tr></table></figure><p>time_to_slc_point()是将时间转换为标准格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">time_to_slc_point</span>(<span class="hljs-params">t: <span class="hljs-type">Union</span>[<span class="hljs-literal">None</span>, <span class="hljs-built_in">str</span>, pd.Timestamp]</span>) -&gt; <span class="hljs-type">Union</span>[<span class="hljs-literal">None</span>, pd.Timestamp]:  <br>    <span class="hljs-string">&quot;&quot;&quot;  </span><br><span class="hljs-string">    Time slicing in Qlib or Pandas is a frequently-used action.    </span><br><span class="hljs-string">    However, user often input all kinds of data format to represent time.    </span><br><span class="hljs-string">    This function will help user to convert these inputs into a uniform format which is friendly to time slicing.  </span><br><span class="hljs-string">    Parameters   </span><br><span class="hljs-string">    ----------    </span><br><span class="hljs-string">    t : Union[None, str, pd.Timestamp]        </span><br><span class="hljs-string">    original time  </span><br><span class="hljs-string">    Returns    </span><br><span class="hljs-string">    -------    </span><br><span class="hljs-string">    Union[None, pd.Timestamp]:    </span><br><span class="hljs-string">    &quot;&quot;&quot;</span>    <br>    <span class="hljs-keyword">if</span> t <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <br>        <span class="hljs-comment"># None represents unbounded in Qlib or Pandas(e.g. df.loc[slice(None, &quot;20210303&quot;)]).  </span><br>        <span class="hljs-keyword">return</span> t  <br>    <span class="hljs-keyword">else</span>:  <br>        <span class="hljs-keyword">return</span> pd.Timestamp(t)<br></code></pre></td></tr></table></figure><p>DataHandler()<br>*<strong>init</strong>: 初始化数据处理器，设置数据加载器和数据范围参数<br>config: 配置数据处理器的参数，主要用于从pickle加载时重新初始化<br>setup_data: 实际加载数据的函数，负责维护self._data<br>fetch: 核心方法，用于从底层数据源获取数据<br>_fetch_data: 实际的数据获取实现，被fetch调用<br>get_cols: 获取列名<br>get_range_selector: 根据当前日期和期数获取日期范围选择器<br>get_range_iterator: 获取按照指定期数切片的数据迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataHandler</span>(<span class="hljs-title class_ inherited__">Serializable</span>):  <br>    <span class="hljs-string">&quot;&quot;&quot;  </span><br><span class="hljs-string">    The steps to using a handler    </span><br><span class="hljs-string">    1. initialized data handler  (call by `init`).    </span><br><span class="hljs-string">    2. use the data.  </span><br><span class="hljs-string">  </span><br><span class="hljs-string">    The data handler try to maintain a handler with 2 level.    </span><br><span class="hljs-string">    `datetime` &amp; `instruments`.  </span><br><span class="hljs-string">    Any order of the index level can be supported (The order will be implied in the data).    </span><br><span class="hljs-string">    The order  &lt;`datetime`, `instruments`&gt; will be used when the dataframe index name is missed.  </span><br><span class="hljs-string">    &quot;&quot;&quot;</span>  <br>    _data: pd.DataFrame  <span class="hljs-comment"># underlying data.  </span><br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">  </span><br><span class="hljs-params">        self,  </span><br><span class="hljs-params">        instruments=<span class="hljs-literal">None</span>,  </span><br><span class="hljs-params">        start_time=<span class="hljs-literal">None</span>,  </span><br><span class="hljs-params">        end_time=<span class="hljs-literal">None</span>,  </span><br><span class="hljs-params">        data_loader: <span class="hljs-type">Union</span>[<span class="hljs-built_in">dict</span>, <span class="hljs-built_in">str</span>, DataLoader] = <span class="hljs-literal">None</span>,  </span><br><span class="hljs-params">        init_data=<span class="hljs-literal">True</span>,  </span><br><span class="hljs-params">        fetch_orig=<span class="hljs-literal">True</span>,  </span><br><span class="hljs-params">    </span>):  <br>        <span class="hljs-string">&quot;&quot;&quot;  </span><br><span class="hljs-string">        Parameters        </span><br><span class="hljs-string">        ----------</span><br><span class="hljs-string">        instruments : The stock list to retrieve.        </span><br><span class="hljs-string">        start_time :  start_time of the original data.        </span><br><span class="hljs-string">        end_time : end_time of the original data.        </span><br><span class="hljs-string">        data_loader : Union[dict, str, DataLoader]    </span><br><span class="hljs-string">        union[]类型提示，表示参数可以是字典、字符串或DataLoader类型中的任意一种。        </span><br><span class="hljs-string">        data loader to load the data.        </span><br><span class="hljs-string">        init_data : initialize the original data in the constructor.        </span><br><span class="hljs-string">        fetch_orig : bool            </span><br><span class="hljs-string">        Return the original data instead of copy if possible.        </span><br><span class="hljs-string">        &quot;&quot;&quot;</span>  <br>        <span class="hljs-comment"># Setup data loader        </span><br>        <span class="hljs-keyword">assert</span> data_loader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>  <br>        <span class="hljs-comment"># to make start_time end_time could have None default value  </span><br><span class="hljs-comment"># 确保data_loader参数不为空，这样可以让start_time和end_time有默认值None。</span><br>        <span class="hljs-comment"># what data source to load data        </span><br>        <span class="hljs-variable language_">self</span>.data_loader = init_instance_by_config(  <br>            data_loader,  <br>            <span class="hljs-literal">None</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isinstance</span>(data_loader, <span class="hljs-built_in">dict</span>) <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;module_path&quot;</span> <span class="hljs-keyword">in</span> data_loader) <span class="hljs-keyword">else</span> data_loader_module,  <br>            accept_types=DataLoader,  <br>        )  <br>  <br>        <span class="hljs-comment"># what data to be loaded from data source  </span><br>        <span class="hljs-comment"># For IDE auto-completion.        </span><br>        <span class="hljs-variable language_">self</span>.instruments = instruments  <br>        <span class="hljs-variable language_">self</span>.start_time = start_time  <br>        <span class="hljs-variable language_">self</span>.end_time = end_time  <br>  <br>        <span class="hljs-variable language_">self</span>.fetch_orig = fetch_orig  <br>        <span class="hljs-keyword">if</span> init_data:  <br>            <span class="hljs-keyword">with</span> TimeInspector.logt(<span class="hljs-string">&quot;Init data&quot;</span>):  <br>                <span class="hljs-variable language_">self</span>.setup_data()  <br>        <span class="hljs-built_in">super</span>().__init__()  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">config</span>(<span class="hljs-params">self, **kwargs</span>):  <br>        <span class="hljs-string">&quot;&quot;&quot;  </span><br><span class="hljs-string">        configuration of data.        </span><br><span class="hljs-string">        # what data to be loaded from data source  </span><br><span class="hljs-string">        This method will be used when loading pickled handler from dataset.        </span><br><span class="hljs-string">        The data will be initialized with different time range.  </span><br><span class="hljs-string">        **kwargs是Python的关键字参数语法，用于接收任意数量的命名参数</span><br><span class="hljs-string">        &quot;&quot;&quot;</span>        <br>        attr_list = &#123;<span class="hljs-string">&quot;instruments&quot;</span>, <span class="hljs-string">&quot;start_time&quot;</span>, <span class="hljs-string">&quot;end_time&quot;</span>&#125;  <br>        <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> kwargs.items():  <br>            <span class="hljs-keyword">if</span> k <span class="hljs-keyword">in</span> attr_list:  <br>                <span class="hljs-built_in">setattr</span>(<span class="hljs-variable language_">self</span>, k, v)  <br>  <br>        <span class="hljs-keyword">for</span> attr <span class="hljs-keyword">in</span> attr_list:  <br>            <span class="hljs-keyword">if</span> attr <span class="hljs-keyword">in</span> kwargs:  <br>                kwargs.pop(attr)  <br>  <br>        <span class="hljs-built_in">super</span>().config(**kwargs)  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setup_data</span>(<span class="hljs-params">self, enable_cache: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span></span>):  <br>        <span class="hljs-string">&quot;&quot;&quot;  </span><br><span class="hljs-string">        Set Up the data in case of running initialization for multiple time  </span><br><span class="hljs-string">        It is responsible for maintaining following variable       </span><br><span class="hljs-string">         1) self._data  </span><br><span class="hljs-string">        Parameters       </span><br><span class="hljs-string">         ----------        </span><br><span class="hljs-string">         enable_cache : bool           </span><br><span class="hljs-string">         default value is false:  </span><br><span class="hljs-string">            - if `enable_cache` == True:  </span><br><span class="hljs-string">                the processed data will be saved on disk, and handler will load the cached data from the disk directly when we call `init` next time        </span><br><span class="hljs-string">        &quot;&quot;&quot;</span>        <br>        <span class="hljs-comment"># Setup data.        </span><br>        <span class="hljs-comment"># _data may be with multiple column index level. The outer level indicates the feature set name        </span><br>        <span class="hljs-keyword">with</span> TimeInspector.logt(<span class="hljs-string">&quot;Loading data&quot;</span>):  <br>        <span class="hljs-comment"># make sure the fetch method is based on an index-sorted pd.DataFrame  </span><br>        <span class="hljs-variable language_">self</span>._data = lazy_sort_index(<span class="hljs-variable language_">self</span>.data_loader.load(<span class="hljs-variable language_">self</span>.instruments, <span class="hljs-variable language_">self</span>.start_time, <span class="hljs-variable language_">self</span>.end_time))  <br>        <span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> cache  </span><br>  <br>    CS_ALL = <span class="hljs-string">&quot;__all&quot;</span>  <span class="hljs-comment"># return all columns with single-level index column  </span><br>    CS_RAW = <span class="hljs-string">&quot;__raw&quot;</span>  <span class="hljs-comment"># return raw data with multi-level index column  </span><br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">  </span><br><span class="hljs-params">        self,  </span><br><span class="hljs-params">        selector: <span class="hljs-type">Union</span>[pd.Timestamp, <span class="hljs-built_in">slice</span>, <span class="hljs-built_in">str</span>, pd.Index] = <span class="hljs-built_in">slice</span>(<span class="hljs-params"><span class="hljs-literal">None</span>, <span class="hljs-literal">None</span></span>), </span><br><span class="hljs-params">        <span class="hljs-comment"># slice(None, None) 是指完整切片</span></span><br><span class="hljs-params">        <span class="hljs-comment"># 如果调用函数时没有提供这些参数，就会使用等号后面的值作为默认值。</span></span><br><span class="hljs-params">        level: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>] = <span class="hljs-string">&quot;datetime&quot;</span>,  </span><br><span class="hljs-params">        col_set: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]] = CS_ALL,  </span><br><span class="hljs-params">        squeeze: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>,  </span><br><span class="hljs-params">        proc_func: <span class="hljs-type">Callable</span> = <span class="hljs-literal">None</span>,  </span><br><span class="hljs-params">    </span>) -&gt; pd.DataFrame:  <br>        <span class="hljs-string">&quot;&quot;&quot;  </span><br><span class="hljs-string">        fetch data from underlying data source  </span><br><span class="hljs-string">        Design motivation:        </span><br><span class="hljs-string">        - providing a unified interface for underlying data.        </span><br><span class="hljs-string">        - Potential to make the interface more friendly.        </span><br><span class="hljs-string">        - User can improve performance when fetching data in this extra layer  </span><br><span class="hljs-string">        Parameters        </span><br><span class="hljs-string">        ----------        </span><br><span class="hljs-string">        selector : Union[pd.Timestamp, slice, str]            </span><br><span class="hljs-string">        describe how to select data by index            </span><br><span class="hljs-string">        It can be categories as following  </span><br><span class="hljs-string">            - fetch single index            </span><br><span class="hljs-string">            - fetch a range of index  </span><br><span class="hljs-string">            - a slice range                </span><br><span class="hljs-string">            - pd.Index for specific indexes  </span><br><span class="hljs-string">            Following conflicts may occur  </span><br><span class="hljs-string">            - Does [&quot;20200101&quot;, &quot;20210101&quot;] mean selecting this slice or these two days?  </span><br><span class="hljs-string">        - slice have higher priorities  </span><br><span class="hljs-string">        level : Union[str, int]            </span><br><span class="hljs-string">        which index level to select the data  </span><br><span class="hljs-string">        col_set : Union[str, List[str]]  </span><br><span class="hljs-string">            - if isinstance(col_set, str):  </span><br><span class="hljs-string">                select a set of meaningful, pd.Index columns.(e.g. features, columns)  </span><br><span class="hljs-string">            - if col_set == CS_RAW:  </span><br><span class="hljs-string">                    the raw dataset will be returned.  </span><br><span class="hljs-string">            - if isinstance(col_set, List[str]):  </span><br><span class="hljs-string">                select several sets of meaningful columns, the returned data has multiple levels  </span><br><span class="hljs-string">        proc_func: Callable  </span><br><span class="hljs-string">            - Give a hook for processing data before fetching            </span><br><span class="hljs-string">            - An example to explain the necessity of the hook:  </span><br><span class="hljs-string">            - A Dataset learned some processors to process data which is related to data segmentation                </span><br><span class="hljs-string">            - It will apply them every time when preparing data.                </span><br><span class="hljs-string">            - The learned processor require the dataframe remains the same format when fitting and applying                </span><br><span class="hljs-string">            - However the data format will change according to the parameters.                 - So the processors should be applied to the underlayer data.  </span><br><span class="hljs-string">        squeeze : bool            </span><br><span class="hljs-string">        whether squeeze columns and index  </span><br><span class="hljs-string">        Returns        </span><br><span class="hljs-string">        -------        </span><br><span class="hljs-string">        pd.DataFrame.        </span><br><span class="hljs-string">        &quot;&quot;&quot;</span>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>._fetch_data(  <br>            data_storage=<span class="hljs-variable language_">self</span>._data,  <br>            selector=selector,  <br>            level=level,  <br>            col_set=col_set,  <br>            squeeze=squeeze,  <br>            proc_func=proc_func,  <br>        )  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_fetch_data</span>(<span class="hljs-params">  </span><br><span class="hljs-params">        self,  </span><br><span class="hljs-params">        data_storage,  </span><br><span class="hljs-params">        selector: <span class="hljs-type">Union</span>[pd.Timestamp, <span class="hljs-built_in">slice</span>, <span class="hljs-built_in">str</span>, pd.Index] = <span class="hljs-built_in">slice</span>(<span class="hljs-params"><span class="hljs-literal">None</span>, <span class="hljs-literal">None</span></span>),  </span><br><span class="hljs-params">        level: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>] = <span class="hljs-string">&quot;datetime&quot;</span>,  </span><br><span class="hljs-params">        col_set: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]] = CS_ALL,  </span><br><span class="hljs-params">        squeeze: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>,  </span><br><span class="hljs-params">        proc_func: <span class="hljs-type">Callable</span> = <span class="hljs-literal">None</span>,  </span><br><span class="hljs-params">    </span>):  <br>        <span class="hljs-comment"># This method is extracted for sharing in subclasses  </span><br>        <span class="hljs-keyword">from</span> .storage <span class="hljs-keyword">import</span> BaseHandlerStorage  <span class="hljs-comment"># pylint: disable=C0415  </span><br>  <br>        <span class="hljs-comment"># Following conflicts may occur        </span><br>        <span class="hljs-comment"># - Does [20200101&quot;, &quot;20210101&quot;] mean selecting this slice or these two days?        </span><br>        <span class="hljs-comment"># To solve this issue        </span><br>        <span class="hljs-comment">#   - slice have higher priorities (except when level is none)        </span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(selector, (<span class="hljs-built_in">tuple</span>, <span class="hljs-built_in">list</span>)) <span class="hljs-keyword">and</span> level <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:  <br>            <span class="hljs-comment"># when level is None, the argument will be passed in directly  </span><br>            <span class="hljs-comment"># we don&#x27;t have to convert it into slice            </span><br>            <span class="hljs-keyword">try</span>:  <br>                selector = <span class="hljs-built_in">slice</span>(*selector)  <br>            <span class="hljs-keyword">except</span> ValueError:  <br>                get_module_logger(<span class="hljs-string">&quot;DataHandlerLP&quot;</span>).info(<span class="hljs-string">f&quot;Fail to converting to query to slice. It will used directly&quot;</span>)  <br>  <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data_storage, pd.DataFrame):  <br>            data_df = data_storage  <br>            <span class="hljs-keyword">if</span> proc_func <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:  <br>                <span class="hljs-comment"># <span class="hljs-doctag">FIXME:</span> fetching by time first will be more friendly to `proc_func`  </span><br>                <span class="hljs-comment"># Copy in case of `proc_func` changing the data inplace....  </span><br>                data_df = proc_func(fetch_df_by_index(data_df, selector, level, fetch_orig=<span class="hljs-variable language_">self</span>.fetch_orig).copy())  <br>                data_df = fetch_df_by_col(data_df, col_set)  <br>            <span class="hljs-keyword">else</span>:  <br>                <span class="hljs-comment"># Fetch column  first will be more friendly to SepDataFrame  </span><br>                data_df = fetch_df_by_col(data_df, col_set)  <br>                data_df = fetch_df_by_index(data_df, selector, level, fetch_orig=<span class="hljs-variable language_">self</span>.fetch_orig)  <br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(data_storage, BaseHandlerStorage):  <br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data_storage.is_proc_func_supported():  <br>                <span class="hljs-keyword">if</span> proc_func <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:  <br>                    <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;proc_func is not supported by the storage <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(data_storage)&#125;</span>&quot;</span>)  <br>                data_df = data_storage.fetch(  <br>                    selector=selector, level=level, col_set=col_set, fetch_orig=<span class="hljs-variable language_">self</span>.fetch_orig  <br>                )  <br>            <span class="hljs-keyword">else</span>:  <br>                data_df = data_storage.fetch(  <br>                    selector=selector, level=level, col_set=col_set, fetch_orig=<span class="hljs-variable language_">self</span>.fetch_orig, proc_func=proc_func  <br>                )  <br>        <span class="hljs-keyword">else</span>:  <br>            <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">f&quot;data_storage should be pd.DataFrame|HashingStockStorage, not <span class="hljs-subst">&#123;<span class="hljs-built_in">type</span>(data_storage)&#125;</span>&quot;</span>)  <br>  <br>        <span class="hljs-keyword">if</span> squeeze:  <br>            <span class="hljs-comment"># squeeze columns  </span><br>            data_df = data_df.squeeze()  <br>            <span class="hljs-comment"># squeeze index  </span><br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(selector, (<span class="hljs-built_in">str</span>, pd.Timestamp)):  <br>                data_df = data_df.reset_index(level=level, drop=<span class="hljs-literal">True</span>)  <br>        <span class="hljs-keyword">return</span> data_df  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_cols</span>(<span class="hljs-params">self, col_set=CS_ALL</span>) -&gt; <span class="hljs-built_in">list</span>:  <br>        <span class="hljs-string">&quot;&quot;&quot;  </span><br><span class="hljs-string">        get the column names  </span><br><span class="hljs-string">        Parameters        </span><br><span class="hljs-string">        ----------        </span><br><span class="hljs-string">        col_set : str            </span><br><span class="hljs-string">        select a set of meaningful columns.(e.g. features, columns)  </span><br><span class="hljs-string">        Returns        </span><br><span class="hljs-string">        -------        </span><br><span class="hljs-string">        list:list of column names        </span><br><span class="hljs-string">        &quot;&quot;&quot;</span>        <br>        df = <span class="hljs-variable language_">self</span>._data.head()  <br>        df = fetch_df_by_col(df, col_set)  <br>        <span class="hljs-keyword">return</span> df.columns.to_list()  <br>  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_range_selector</span>(<span class="hljs-params">self, cur_date: <span class="hljs-type">Union</span>[pd.Timestamp, <span class="hljs-built_in">str</span>], periods: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">slice</span>:  <br>        <span class="hljs-string">&quot;&quot;&quot;  </span><br><span class="hljs-string">        get range selector by number of periods  </span><br><span class="hljs-string">        Args:     </span><br><span class="hljs-string">        cur_date (pd.Timestamp or str): current date            </span><br><span class="hljs-string">        periods (int): number of periods        </span><br><span class="hljs-string">        &quot;&quot;&quot;</span>       <br>        <span class="hljs-comment"># 获取数据索引中唯一的日期时间值 </span><br>        trading_dates = <span class="hljs-variable language_">self</span>._data.index.unique(level=<span class="hljs-string">&quot;datetime&quot;</span>)<br>        <span class="hljs-comment"># 获取当前日期在交易日期序列中的位置  </span><br>        cur_loc = trading_dates.get_loc(cur_date)  <br>        <span class="hljs-comment"># 计算起始位置（当前位置减去周期数加1）</span><br>        pre_loc = cur_loc - periods + <span class="hljs-number">1</span>  <br>        <span class="hljs-comment"># 如果起始位置小于0，发出警告并将起始位置设为0</span><br>        <span class="hljs-keyword">if</span> pre_loc &lt; <span class="hljs-number">0</span>:  <br>            warnings.warn(<span class="hljs-string">&quot;`periods` is too large. the first date will be returned.&quot;</span>)  <br>            pre_loc = <span class="hljs-number">0</span>  <br>        <span class="hljs-comment"># 获取参考日期（起始日期）</span><br>        ref_date = trading_dates[pre_loc]  <br>        <span class="hljs-comment"># 返回一个切片对象，从参考日期到当前日期</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">slice</span>(ref_date, cur_date)  <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_range_iterator</span>(<span class="hljs-params">  </span><br><span class="hljs-params">        self, periods: <span class="hljs-built_in">int</span>, min_periods: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span>, **kwargs  </span><br><span class="hljs-params">    </span>) -&gt; Iterator[<span class="hljs-type">Tuple</span>[pd.Timestamp, pd.DataFrame]]:  <br>        <span class="hljs-string">&quot;&quot;&quot;  </span><br><span class="hljs-string">        get an iterator of sliced data with given periods  </span><br><span class="hljs-string">        Args:            </span><br><span class="hljs-string">        periods (int): number of periods.            </span><br><span class="hljs-string">        min_periods (int): minimum periods for sliced dataframe.            </span><br><span class="hljs-string">        kwargs (dict): will be passed to `self.fetch`.        </span><br><span class="hljs-string">        &quot;&quot;&quot;</span>     <br>        <span class="hljs-comment"># 获取数据索引中唯一的日期时间值   </span><br>        trading_dates = <span class="hljs-variable language_">self</span>._data.index.unique(level=<span class="hljs-string">&quot;datetime&quot;</span>)<br>        <span class="hljs-comment"># 如果未指定最小周期数，则使用periods作为最小周期数  </span><br>        <span class="hljs-keyword">if</span> min_periods <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:  <br>            min_periods = periods  <br>        <span class="hljs-comment"># 从最小周期数位置开始遍历交易日期</span><br>        <span class="hljs-keyword">for</span> cur_date <span class="hljs-keyword">in</span> trading_dates[min_periods:]: <br>        <span class="hljs-comment"># 获取当前日期的范围选择器 </span><br>            selector = <span class="hljs-variable language_">self</span>.get_range_selector(cur_date, periods)  <br>            <span class="hljs-comment"># 使用yield返回当前日期和对应的数据切片</span><br>            <span class="hljs-keyword">yield</span> cur_date, <span class="hljs-variable language_">self</span>.fetch(selector, **kwargs)  <br>DATA_KEY_TYPE = <span class="hljs-type">Literal</span>[<span class="hljs-string">&quot;raw&quot;</span>, <span class="hljs-string">&quot;infer&quot;</span>, <span class="hljs-string">&quot;learn&quot;</span>]<br></code></pre></td></tr></table></figure><p>其中用到的函数有：</p><p>lazy_sort_index（）：</p><ul><li>根据axis选择处理index还是columns</li><li>检查三个条件：<ol><li>索引是否非递增</li><li>是否使用旧版pandas</li><li>对于多重索引，检查是否已经按字典序排序</li></ol></li><li>如果需要排序，则调用sort_index；否则直接返回原DataFrame</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python">is_deprecated_lexsorted_pandas = version.parse(pd.__version__) &gt; version.parse(<span class="hljs-string">&quot;1.3.0&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">lazy_sort_index</span>(<span class="hljs-params">df: pd.DataFrame, axis=<span class="hljs-number">0</span></span>) -&gt; pd.DataFrame:  <br>    <span class="hljs-string">&quot;&quot;&quot;  </span><br><span class="hljs-string">    make the df index sorted  </span><br><span class="hljs-string">    df.sort_index() will take a lot of time even when `df.is_lexsorted() == True`</span><br><span class="hljs-string">    This function could avoid such case  </span><br><span class="hljs-string">    Parameters   </span><br><span class="hljs-string">    ----------    </span><br><span class="hljs-string">    df : pd.DataFrame  </span><br><span class="hljs-string">    Returns    </span><br><span class="hljs-string">    -------    </span><br><span class="hljs-string">    pd.DataFrame: sorted dataframe    </span><br><span class="hljs-string">    &quot;&quot;&quot;</span>    <br>    idx = df.index <span class="hljs-keyword">if</span> axis == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> df.columns  <br>    <span class="hljs-keyword">if</span> (  <br>        <span class="hljs-keyword">not</span> idx.is_monotonic_increasing  <br>        <span class="hljs-comment">#索引是否递增</span><br>        <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> is_deprecated_lexsorted_pandas  <br>        <span class="hljs-keyword">and</span> <span class="hljs-built_in">isinstance</span>(idx, pd.MultiIndex) <br>        <span class="hljs-comment">#检查idx是否是pd.MultiIndex的格式 </span><br>        <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> idx.is_lexsorted()  <br>        <span class="hljs-comment">#按字典序排序</span><br>    ):  <span class="hljs-comment"># this case is for the old version  </span><br>        <span class="hljs-keyword">return</span> df.sort_index(axis=axis)  <br>    <span class="hljs-keyword">else</span>:  <br>        <span class="hljs-keyword">return</span> df  <br>  <br>  <br>FLATTEN_TUPLE = <span class="hljs-string">&quot;_FLATTEN_TUPLE&quot;</span><br></code></pre></td></tr></table></figure><p>fetch_df_by_col():用于从 pandas DataFrame 中获取特定列集。</p><p>参数说明:</p><ul><li><code>df</code>: pandas DataFrame 对象</li><li><code>col_set</code>: 可以是字符串或字符串列表，用于指定要获取的列集</li></ul><p>函数的主要逻辑:</p><ol><li><p>首先检查两个条件:</p><ul><li>DataFrame 的列是否是 MultiIndex(多级索引)</li><li>col_set 是否等于 DataHandler.CS_RAW<br>  如果满足任一条件,直接返回原始 DataFrame</li></ul></li><li><p>如果 col_set 等于 DataHandler.CS_ALL:</p><ul><li>使用 droplevel 方法删除第一级索引(axis&#x3D;1 表示在列方向)</li><li>返回处理后的 DataFrame</li></ul></li><li><p>其他情况:</p><ul><li>使用 loc 访问器根据指定的 col_set 选择相应的列</li><li>返回包含选定列的 DataFrame</li></ul></li></ol><p>这个函数主要用于处理具有多级列索引的 DataFrame，可以:</p><ul><li>返回原始数据(CS_RAW)</li><li>返回删除第一级索引后的所有数据(CS_ALL)</li><li>返回指定列集的数据<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fetch_df_by_col</span>(<span class="hljs-params">df: pd.DataFrame, col_set: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]]</span>) -&gt; pd.DataFrame:  <br>    <span class="hljs-keyword">from</span> .handler <span class="hljs-keyword">import</span> DataHandler  <span class="hljs-comment"># pylint: disable=C0415  </span><br>  <br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(df.columns, pd.MultiIndex) <span class="hljs-keyword">or</span> col_set == DataHandler.CS_RAW: <br>        <span class="hljs-keyword">return</span> df  <br>    <span class="hljs-keyword">elif</span> col_set == DataHandler.CS_ALL:  <br>        <span class="hljs-keyword">return</span> df.droplevel(axis=<span class="hljs-number">1</span>, level=<span class="hljs-number">0</span>)  <br>    <span class="hljs-keyword">else</span>:  <br>        <span class="hljs-keyword">return</span> df.loc(axis=<span class="hljs-number">1</span>)[col_set]<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">init_instance_by_config</span>(<span class="hljs-params">  </span><br><span class="hljs-params">    config: InstConf,  </span><br><span class="hljs-params">    default_module=<span class="hljs-literal">None</span>,  </span><br><span class="hljs-params">    accept_types: <span class="hljs-type">Union</span>[<span class="hljs-built_in">type</span>, <span class="hljs-type">Tuple</span>[<span class="hljs-built_in">type</span>]] = (<span class="hljs-params"></span>),  </span><br><span class="hljs-params">    try_kwargs: <span class="hljs-type">Dict</span> = &#123;&#125;,  </span><br><span class="hljs-params">    **kwargs,  </span><br><span class="hljs-params"></span>) -&gt; <span class="hljs-type">Any</span>:  <br>    <span class="hljs-string">&quot;&quot;&quot;  </span><br><span class="hljs-string">    get initialized instance with config  </span><br><span class="hljs-string">    Parameters   </span><br><span class="hljs-string">     ----------    </span><br><span class="hljs-string">     config : InstConf  </span><br><span class="hljs-string">    default_module : Python module        </span><br><span class="hljs-string">    Optional. It should be a python module.        </span><br><span class="hljs-string">    NOTE: the &quot;module_path&quot; will be override by `module` arguments  </span><br><span class="hljs-string">    This function will load class from the config[&#x27;module_path&#x27;] first.        </span><br><span class="hljs-string">    If config[&#x27;module_path&#x27;] doesn&#x27;t exists, it will load the class from default_module.  </span><br><span class="hljs-string">    accept_types: Union[type, Tuple[type]]  Optional. </span><br><span class="hljs-string">    If the config is a instance of specific type, return the config directly.      </span><br><span class="hljs-string">    This will be passed into the second parameter of isinstance.  </span><br><span class="hljs-string">    try_kwargs: Dict      </span><br><span class="hljs-string">    Try to pass in kwargs in `try_kwargs` when initialized the instance       </span><br><span class="hljs-string">     If error occurred, it will fail back to initialization without try_kwargs.  </span><br><span class="hljs-string">    Returns  </span><br><span class="hljs-string">-------    </span><br><span class="hljs-string">object: An initialized object based on the config info    </span><br><span class="hljs-string">&quot;&quot;&quot;</span>    <br><span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(config, accept_types):  <br>        <span class="hljs-keyword">return</span> config  <br>  <br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(config, (<span class="hljs-built_in">str</span>, Path)):  <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(config, <span class="hljs-built_in">str</span>):  <br>            <span class="hljs-comment"># path like &#x27;file:///&lt;path to pickle file&gt;/obj.pkl&#x27;  </span><br>            pr = urlparse(config)  <br>            <span class="hljs-keyword">if</span> pr.scheme == <span class="hljs-string">&quot;file&quot;</span>:  <br>  <br>        <span class="hljs-comment"># To enable relative path like file://data/a/b/c.pkl.  pr.netloc will be data  </span><br>                path = pr.path  <br>                <span class="hljs-keyword">if</span> pr.netloc != <span class="hljs-string">&quot;&quot;</span>:  <br>                    path = path.lstrip(<span class="hljs-string">&quot;/&quot;</span>)  <br>  <br>                pr_path = os.path.join(pr.netloc, path) <span class="hljs-keyword">if</span> <span class="hljs-built_in">bool</span>(pr.path) <span class="hljs-keyword">else</span> pr.netloc  <br>                <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(os.path.normpath(pr_path), <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:  <br>                    <span class="hljs-keyword">return</span> pickle.load(f)  <br>        <span class="hljs-keyword">else</span>:  <br>            <span class="hljs-keyword">with</span> config.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:  <br>                <span class="hljs-keyword">return</span> pickle.load(f)  <br>  <br>    klass, cls_kwargs = get_callable_kwargs(config, default_module=default_module)  <br>  <br>    <span class="hljs-keyword">try</span>:  <br>        <span class="hljs-keyword">return</span> klass(**cls_kwargs, **try_kwargs, **kwargs)  <br>    <span class="hljs-keyword">except</span> (TypeError,):  <br>        <span class="hljs-comment"># TypeError for handling errors like  </span><br>        <span class="hljs-comment"># 1: `XXX() got multiple values for keyword argument &#x27;YYY&#x27;`        </span><br>        <span class="hljs-comment"># 2: `XXX() got an unexpected keyword argument &#x27;YYY&#x27;        </span><br>        <span class="hljs-keyword">return</span> klass(**cls_kwargs, **kwargs)<br></code></pre></td></tr></table></figure><p>这段代码实现了一个通过配置信息来初始化对象实例的函数。</p><ol><li>函数参数说明：</li></ol><ul><li><code>config</code>: InstConf类型的配置信息</li><li><code>default_module</code>: 可选的默认Python模块</li><li><code>accept_types</code>: 接受的类型，如果config是这些类型之一则直接返回</li><li><code>try_kwargs</code>: 尝试用于初始化的额外参数字典</li><li><code>kwargs</code>: 其他关键字参数</li></ul><ol start="2"><li>主要逻辑流程：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 如果config本身就是指定的accept_types类型之一，直接返回</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(config, accept_types):<br>    <span class="hljs-keyword">return</span> config<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 处理字符串或Path类型的配置</span><br><span class="hljs-comment"># 支持从pickle文件加载对象</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(config, (<span class="hljs-built_in">str</span>, Path)):<br>    <span class="hljs-comment"># 处理形如 &#x27;file:///&lt;path&gt;/obj.pkl&#x27; 的文件路径</span><br>    <span class="hljs-comment"># 从pickle文件中加载并返回对象</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取类和初始化参数</span><br>klass, cls_kwargs = get_callable_kwargs(config, default_module=default_module)<br><br><span class="hljs-comment"># 尝试初始化对象</span><br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 首先尝试使用try_kwargs初始化</span><br>    <span class="hljs-keyword">return</span> klass(**cls_kwargs, **try_kwargs, **kwargs)<br><span class="hljs-keyword">except</span> (TypeError,):<br>    <span class="hljs-comment"># 如果失败(比如参数重复或未知参数)，则不使用try_kwargs重试</span><br>    <span class="hljs-keyword">return</span> klass(**cls_kwargs, **kwargs)<br></code></pre></td></tr></table></figure><ol start="3"><li>特殊功能：</li></ol><ul><li>支持从pickle文件加载对象，可以使用file:&#x2F;&#x2F;协议的URL格式</li><li>支持相对路径和绝对路径</li><li>提供了容错机制，当使用try_kwargs初始化失败时会自动重试</li><li>灵活的类型处理：可以直接返回符合类型的对象，或者通过配置创建新实例</li></ul><ol start="4"><li>使用场景示例：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 直接返回已存在实例</span><br>config = existing_instance<br>result = init_instance_by_config(config, accept_types=(ExistingClass,))<br><br><span class="hljs-comment"># 从pickle文件加载</span><br>config = <span class="hljs-string">&quot;file:///path/to/object.pkl&quot;</span><br>result = init_instance_by_config(config)<br><br><span class="hljs-comment"># 通过配置创建新实例</span><br>config = &#123;<br>    <span class="hljs-string">&quot;module_path&quot;</span>: <span class="hljs-string">&quot;package.module&quot;</span>,<br>    <span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;ClassName&quot;</span>,<br>    <span class="hljs-string">&quot;kwargs&quot;</span>: &#123;<span class="hljs-string">&quot;param1&quot;</span>: <span class="hljs-string">&quot;value1&quot;</span>&#125;<br>&#125;<br>result = init_instance_by_config(config)<br></code></pre></td></tr></table></figure><p>这个函数提供了很大的灵活性，可以通过多种方式初始化对象，适合用于配置驱动的系统架构中。</p><p>需要注意的是，代码中引用了一个<code>get_callable_kwargs</code>函数，这个函数负责从配置中解析出类和初始化参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_callable_kwargs</span>(<span class="hljs-params">config: InstConf, default_module: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, ModuleType] = <span class="hljs-literal">None</span></span>) -&gt; (<span class="hljs-built_in">type</span>, <span class="hljs-built_in">dict</span>):  <br>    <span class="hljs-string">&quot;&quot;&quot;  </span><br><span class="hljs-string">    extract class/func and kwargs from config info  </span><br><span class="hljs-string">    Parameters    </span><br><span class="hljs-string">    ----------    </span><br><span class="hljs-string">    config : [dict, str]        </span><br><span class="hljs-string">    similar to config       </span><br><span class="hljs-string">     please refer to the doc of init_instance_by_config  </span><br><span class="hljs-string">    default_module : Python module or str        </span><br><span class="hljs-string">    It should be a python module to load the class type       </span><br><span class="hljs-string">     This function will load class from the config[&#x27;module_path&#x27;] first.        </span><br><span class="hljs-string">     If config[&#x27;module_path&#x27;] doesn&#x27;t exists, it will load the class from default_module.  </span><br><span class="hljs-string">    Returns    </span><br><span class="hljs-string">    -------    </span><br><span class="hljs-string">    (type, dict):        </span><br><span class="hljs-string">    the class/func object and it&#x27;s arguments.  </span><br><span class="hljs-string">    Raises    </span><br><span class="hljs-string">    ------        </span><br><span class="hljs-string">    ModuleNotFoundError    </span><br><span class="hljs-string">    &quot;&quot;&quot;</span>    <br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(config, <span class="hljs-built_in">dict</span>):  <br>        key = <span class="hljs-string">&quot;class&quot;</span> <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;class&quot;</span> <span class="hljs-keyword">in</span> config <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;func&quot;</span>  <br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(config[key], <span class="hljs-built_in">str</span>):  <br>            <span class="hljs-comment"># 1) get module and class  </span><br>            <span class="hljs-comment"># - case 1): &quot;a.b.c.ClassName&quot;           </span><br>             <span class="hljs-comment"># - case 2): &#123;&quot;class&quot;: &quot;ClassName&quot;, &quot;module_path&quot;: &quot;a.b.c&quot;&#125;            m_path, cls = split_module_path(config[key])  </span><br>            <span class="hljs-keyword">if</span> m_path == <span class="hljs-string">&quot;&quot;</span>:  <br>                m_path = config.get(<span class="hljs-string">&quot;module_path&quot;</span>, default_module)  <br>            module = get_module_by_module_path(m_path)  <br>  <br>            <span class="hljs-comment"># 2) get callable  </span><br>            _<span class="hljs-built_in">callable</span> = <span class="hljs-built_in">getattr</span>(module, cls)  <span class="hljs-comment"># may raise AttributeError  </span><br>        <span class="hljs-keyword">else</span>:  <br>            _<span class="hljs-built_in">callable</span> = config[key]  <span class="hljs-comment"># the class type itself is passed in  </span><br>        kwargs = config.get(<span class="hljs-string">&quot;kwargs&quot;</span>, &#123;&#125;)  <br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(config, <span class="hljs-built_in">str</span>):  <br>        <span class="hljs-comment"># a.b.c.ClassName  </span><br>        m_path, cls = split_module_path(config)  <br>        module = get_module_by_module_path(default_module <span class="hljs-keyword">if</span> m_path == <span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">else</span> m_path)  <br>  <br>        _<span class="hljs-built_in">callable</span> = <span class="hljs-built_in">getattr</span>(module, cls)  <br>        kwargs = &#123;&#125;  <br>    <span class="hljs-keyword">else</span>:  <br>        <span class="hljs-keyword">raise</span> NotImplementedError(<span class="hljs-string">f&quot;This type of input is not supported&quot;</span>)  <br>    <span class="hljs-keyword">return</span> _<span class="hljs-built_in">callable</span>, kwargs  <br>  <br>  <br>get_cls_kwargs = get_callable_kwargs  <span class="hljs-comment"># <span class="hljs-doctag">NOTE:</span> this is for compatibility for the previous version</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2024/11/13/test/"/>
    <url>/2024/11/13/test/</url>
    
    <content type="html"><![CDATA[<p>测试：<br><img src="/2024/11/13/test/image-20241113152958547.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/11/12/hello-world/"/>
    <url>/2024/11/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
